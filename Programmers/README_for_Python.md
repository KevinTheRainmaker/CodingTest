# Programmers_CodingTest

## Python

**1. 가운데 글자 가져오기**<br/>

![1  가운데 글자 가져오기](https://user-images.githubusercontent.com/76294398/104676333-836af580-572a-11eb-980e-ace4bf72de0a.jpg)<br/><br/>
프로그래머스 코딩 테스트 Lv.1 첫 번째 연습문제이다.<br/><br/>
1월 15일 기준 약 24200명이 풀었다.<br/>
순간적으로 문자열의 특정 인덱스의 문자를 가져오는 방법이 헷갈렸다. 기본을 확실히 다져야겠다는 생각이 들게 해준 문제다.<br/><br/>
파이썬을 제대로 공부한 사람이라면 쉽게 알겠지만, 문자열의 n번째 문자를 가져오는 방법은 '문자열'[n-1]이다.<br/>
이를 이용하면 쉽게 풀 수 있다.<br/>
물론 문자열의 문자 개수가 짝수개인지 홀수개인지를 판별하는 부분이 코드에 반드시 포함되어야 할 것이다.<br/>
try-except도 아니고 단순한 if-else를 사용하면 되니 그닥 어렵지는 않았을 것이라 생각된다.<br/><br/>


**2. 같은 숫자는 싫어**

![같은 숫자는 싫어](https://user-images.githubusercontent.com/76294398/104810811-9a007200-583a-11eb-940c-162cf882d017.jpg)<br/><br/>
프로그래머스 코딩 테스트 Lv.1 두 번째 연습문제이다.<br/><br/>
1월 16일 기준 약 17,300명이 풀었다.<br/>
반복과 비교를 통해 문제를 풀어야 할 것 같다.<br/>
먼저, arr의 첫 번째 인자는 무조건 answer에 들어갈 수 밖에 없기에, 바로 넣어주었다.<br/>
이후, arr의 두번째 인자부터 마지막 인자까지 반복을 통해 같으면 넘어가고, 다르면 넣어주도록 하였다.<br/>
이때, answer과 arr은 모두 '리스트'이므로 리스트의 기능인 index와 append를 사용하였다.<br/><br/>
조금만 생각해보면 상당히 쉬운 문제이며, 다른 방법도 얼마든지 있을 수 있는 문제이니<br/>
꼭 풀어보기를 바란다.<br/><br/>


**3. 나누어 떨어지는 숫자 배열**

![나누어 떨어지는 숫자 배열](https://user-images.githubusercontent.com/76294398/104833164-05e5e780-58da-11eb-87b7-a1bcd8d7d3d4.jpg)<br/><br/>
프로그래머스 코딩 테스트 Lv.1 세 번째 연습문제이다.<br/><br/>
1월 17일 기준 약 17,250명이 풀었다.<br/>
이번에도 반복과 비교를 통해서 문제를 풀었다.<br/>
주어지는 arr의 길이를 미리 알 수 없으므로 for문을 통해 arr의 길이만큼 반복하도록 하였다.<br/>
i는 0부터 arr의 길이만큼 증가하면서 arr의 i번째 인덱스를 불러온다.<br/>
불러온 값을 divisor로 나눈 나머지가 0이라면(나누어 떨어진다면), 해당값을 answer에 append 해준다.<br/>
만약 나머지가 0이 아니라면 그냥 answer을 반환하고 넘어간다.<br/><br/>
위 과정을 arr 내 모든 값에 대하여 실행함으로써 answer가 완성이 되면, answer의 값 유무를 확인한다.<br/>
모든 값이 divisor로 나누어 떨어지지 않아 answer이 비어있는 경우(answer의 길이가 0인 경우),<br/>
문제 조건에 나와있는대로 -1을 answer에 넣어준다.<br/><br/>
여기까지 완료했다면 이제 마지막 단계이다.<br/>
완성된 answer을 오름차순으로 정리해주면 된다.<br/>
파이썬에서는 sort()라는 내장함수를 이용하여 손쉽게 오름차순 정렬이 가능하다.<br/>
이렇게 오름차순 정렬까지 완료한 후에 answer을 리턴해주면 끝.<br/><br/>
그런데 약간 문제가 생겼다. 몇몇 케이스에 대한 실행시간이 비정상적으로 길다.<br/><br/>
![나떨숫배 미흡점](https://user-images.githubusercontent.com/76294398/104833450-11d2a900-58dc-11eb-8b32-9985d1a94e72.jpg)<br/>
어찌보면 사소한 문제이지만, 이런게 쌓이게 된다면 큰 문제가 될 수 있지 않을까.<br/>
이 문제는 차차 고쳐나가보도록 하자. 이유와 해결방법은 모두 이 문서에 기록할 것이다.<br/><br/>


**4. 문자열 내 p와 y 개수**

![py](https://user-images.githubusercontent.com/76294398/105623408-e2341b80-5e5c-11eb-920d-40b82a2532d0.jpg)<br/><br/>
프로그래머스 코딩 테스트 Lv.1 네 번째 연습문제이다.<br/><br/>
1월 18일 기준 약 17,000명이 풀었다.<br/>
answer 대신 boolean 형식을 사용하기 위해 기존에 있던 answer 변수는 삭제해 주었다.<br/>
대소문자는 비교하지 않으므로 소스코드의 편한 작성을 위해 모두 소문자로 처리해주었다.<br/>
이후 p와 y라는 변수를 두어 p와 y의 개수를 셀 수 있도록 하였다.<br/><br/>
이전 문제와 마찬가지로 반복과 비교를 이용하면 쉽게 풀릴 것 같다.<br/>
s의 길이만큼 반복하여 s의 i번째 인덱스를 가지는 문자가 p거나 y일 경우,<br/>
앞서 선언해준 변수 p와 y가 하나씩 증가하도록 하였다.<br/><br/>
이제 모든 반복과 비교가 종료되었으니 변수 p와 변수 y의 값이 같은지를 판별하면 된다.<br/>
같으면 True를 반환하라고 하였으니 p==y를 return해주면 된다.<br/><br/>


**5. 문자열 내 마음대로 정렬하기**

![내맘](https://user-images.githubusercontent.com/76294398/105623412-e4967580-5e5c-11eb-886f-ecc356c6d703.jpg)<br/><br/>
프로그래머스 코딩 테스트 Lv.1 다섯 번째 연습문제이다.<br/><br/>
1월 19일 기준 약 11,500명이 풀었다.<br/>
언제나처럼 반복과 비교로 문제를 해결하였다.<br/>
가장 기본적인 툴인만큼 자유자재로 사용할 수 있게 연습해야한다.<br/><br/>
n번째 글자에 대해 오름차순으로 정렬한다는게 처음에는 굉장히 당혹스러웠다.<br/>
심지어 n번째 글자가 같은 경우에는 가장 첫 번째 글자가 정렬 기준이 된다니..<br/>
한참을 고민하던 중, 이런 생각이 떠올랐다.<br/><br/>
'정렬 기준 1순위는 n번째, 2순위는 첫 번째.. sort는 앞에서부터 정렬 기준 순위를 메긴다...'<br/><br/>
정말 간단하면서 확실한 방법이 떠올랐다. 순간 나도 모르게 이마를 탁 쳤다.<br/>
바로 'n번째 글자를 strings 맨 앞에 붙이고 sort'하는 것이다.<br/>
즉시 코드로 옮기기로 했다.<br/><br/>
i번째 strings 앞에 각각의 n번째 글자를 붙여주었다.<br/>
이후 sort()함수를 사용해 정렬을 시행해줌으로써 주어진 순서대로 정렬을 성공했다.<br/><br/>
하지만 여기서 끝냈다면 문제를 틀렸을 것이다.<br/>
아직 strings를 원래대로 고쳐주지 않았지않은가!<br/>
따라서 다시 반복을 통해 슬라이싱해주어 원래 문자열로 돌려주었다.<br/><br/>
return값은 answer이라는 리스트이므로 완성된 문자열을 차례로 append 해주면 끝이다.<br/><br/>


**6. 서울에서 김서방 찾기**

![김서방](https://user-images.githubusercontent.com/76294398/105623411-e3fddf00-5e5c-11eb-8362-4852c365e6bb.jpg)<br/><br/>
프로그래머스 코딩 테스트 Lv.1 여섯 번째 연습문제이다.<br/><br/>
1월 20일 기준 약 20,300명이 풀었다.<br/>
솔직히 아무 생각없이 푼 느낌이 강한 문제였다.<br/>
분명 다른 더 좋은 방법이 있을 것이다. 하지만 왜인지는 아직 알 수가 없다.<br/>
추후 알게 된다면 수정하도록 하겠다.<br/><br/>


**7. 소수 찾기**

![sosu](https://user-images.githubusercontent.com/76294398/105623410-e3654880-5e5c-11eb-9740-60f9b6dee684.jpg)<br/><br/>
프로그래머스 코딩 테스트 Lv.1 일곱 번째 연습문제이다.<br/><br/>
1월 21일 기준 약 11,300명이 풀었다.<br/>
'소수'하면 가장 먼저 떠오르는 체가 있다.<br/>
바로 '에라토스테네스의 체'이다.<br/>
그리스의 수학자이자 지리학자인 에라토스테네스가 고안한 소수(素數)를 찾는 방법으로,<br/>
2부터 시작해 자연수를 차례로 쓴 다음, 2 이외의 2의 배수, 3 이외의 3의 배수, <br/>
5 이외의 5의 배수...의 순서로 수를 지워나가 끝에 남는 수가 소수이다.<br/>
어찌보면 약간 노가다(?)성이 있지만, 컴퓨터에게 이 정도는 일도 아니다.<br/><br/>
먼저 answer에 2부터 n까지의 집합을 주었다.<br/>
이후 반복을 통해 i의 배수인 수를 answer 집합에서 빼나가는 식으로 지워줬다.<br/>
마지막으로 answer 집합 내 개수, 즉 길이를 return해주면 끝이 난다.<br/><br/>
이 외에 수학적으로도 풀 수 있는 재미있는 문제이니 꼭 한번 풀어보았으면 좋겠다.<br/><br/>
