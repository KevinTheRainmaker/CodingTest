# Programmers_CodingTest

## C

**1. 2016년**<br/>

![2016년P](https://user-images.githubusercontent.com/76294398/104171021-588c5300-5445-11eb-94a4-5a3f07b064aa.jpg)<br/><br/>
프로그래머스에서 코딩테스트 연습 Lv.1을 선택하면 제일 처음 나타나는 문제이다.<br/>
대략 만 명 정도가 푼, 다소 쉬운 문제라고 할 수 있다.<br/><br/>
날짜를 입력 받아 2016년 a월 b일이 무슨 요일인지 맞추는 프로그램을 작성하면 된다.<br/><br/>
제한조건에 의하면, 2016년은 윤년이므로 2월이 29일까지 있음을 알 수 있다. 이 부분에서 어이없이 실수했다면<br/>
3월 이상에서는 답이 제대로 나오지 않았을 것이다.<br/><br/>
리턴할 값은 메모리를 동적 할당해주라는 문구가 보이고, 그 아래 malloc함수가 보인다.<br/><br/>
return할 값인 answer을 malloc을 사용하여 동적 할당 해주어야 할 것 같다.<br/><br/>
week라는 7칸의 배열을 만들고 그 안에 요일을 넣었다. 그런데, 보통이랑은 다른 점이 눈에 띤다.<br/>
보통의 경우 일요일이나 월요일부터 작성하는데, 이 코드에서는 목요일(THU)부터 작성하였다.<br/>
그 이유는 2016년 1월1일이 금요일이기 때문이다.<br/><br/>
무슨 말인지 잘 생각해보자. 1월 1일이 금요일인 경우, 7일 뒤인 1월 8일에 다시 금요일이 돌아온다.<br/>
즉, a월 b일까지의 일수(1월 1일 포함)에 7을 나눈 나머지가 1이 되면 금요일, 0이 되면 목요일이 된다.<br/>
따라서, 0번째 배열에는 목요일인 THU, 1번째 배열에는 금요일인 FRI...와 같은 순서대로 요일이 들어가게 된다.<br/>
7로 나눈 나머지와 해당 배열의 n번째 요일이 일치하게 되는 것이다.<br/><br/>
그 다음으로는 month라는 13칸의 배열을 만들어 각 월의 전체 일수를 저장하였다. 여기서도 독특한 점이 보이는데,<br/>
12월 체계를 따른 12칸이 아닌 13칸이라는 점이다. 이는 이후 계산 방식에 따른 특징이다.<br/><br/> 
for문을 보면, sum이라는 초기값 0의 변수에 i가 a-1이 될 때까지 month배열 내의 수를 더한다.<br/>
이때 만약 a가 1, 즉 1월 b일이 입력될 경우, 아직 한 달이 채 지나지 않았으므로 '월'에 의한 날짜증가는 이루어지지 않기 때문이다.<br/><br/> 
이렇게 a월 b일에 의한 날짜증가가 이루어져 sum 이라는 변수에 저장된 후, sum을 7로 나눈 나머지를 answer로 반환하면 해당 날짜에 대한 요일이 반환된다.<br/><br/>


**2. 두 정수 사이 합**<br/>

![두정합](https://user-images.githubusercontent.com/76294398/104171722-6ee6de80-5446-11eb-9baf-cdb68ad66402.jpg)<br/><br/>
프로그래머스 코딩테스트 Lv.1 두 번째 문제이다.<br/>
약 만 이천 명 정도가 푼 문제이므로 이 또한 쉬운 축에 든다고 할 수 있다.<br/><br/>
두 정수 a와 b를 입력받은 후, 입력받은 두 정수 사이에 있는 정수들의 합을 구하는 소스코드를 작성해야 한다.<br/>
제한 조건에 의하면 a와 b의 대소 관계는 정해져 있지 않으므로 어느 것이 더 큰 수 인지 판별하는 과정이 필요할 듯하다.<br/><br/>
두 수가 같을 경우 아무 수나 리턴하라고 하였으니 그냥 a를 리턴하기로 하자.<br/>
a와 b가 ±10,000,000의 범위를 가지는 탓에 둘 사이 정수의 합이 굉장히 커질 수 있으므로 int가 아닌 long long을 사용한다.<br/><br/>
일단 먼저, 조건문을 사용하여 a와 b가 같을 경우 a를 리턴하도록 하였다.<br/><br/>
조건문은 위에서부터 참 거짓을 판별하여 조건이 참일 경우 해당 조건문 안의 함수를 실행하여 리턴 값을 반환한 후 조건문을 종료한다.<br/>
따라서 첫 번째 조건문의 조건이 거짓일 경우(a와 b가 같지 않을 경우) 그 아래의 조건문을 차례로 실행한다.<br/><br/>
a와 b가 같지 않다면, 둘 중 어느 하나는 다른 하나에 비해 클 것이므로 그에 대한 조건문을 작성해 준다.<br/>
만약 항상 a가 작고 b가 크다면 else 문만을 이용하면 되지만 그렇지 않기에 if 문을 한 번 더 사용해 준다.<br/><br/>
이렇게, a와 b 중 어느 것이 더 큰 지 판별했다면, 이제 계산을 실행해야 한다.<br/>
조건문 내에 반복문인 for 문을 사용하여 작은 수부터 큰 수까지 반복함으로써 answer을 갱신하고 반복문이 종료됨과 동시에 answer을 리턴한다.<br/><br/>

**3. 수박수박수박수박수박수?**<br/>

![수박](https://user-images.githubusercontent.com/76294398/104172118-1401b700-5447-11eb-92ca-40e9de23db14.jpg)<br/><br/>
프로그래머스 코딩테스트 Lv.1 세 번째 문제이다.<br/><br/>
약 만 이천 명 정도가 풀었으니 이 또한 쉬운 문제 같았으나 생각보다 어려웠다.<br/><br/>
어째서 지금까지의 문제들보다 많은 사람들이 풀었는지 의문이다. 오히려 적당히 어려워서 그런 걸까?<br/><br/>
'수'와 '박'을 번갈아가면서 n 개의 문자를 출력하는 소스코드를 작성해야 한다.<br/><br/>
제한 조건은 딱히 고려할 게 없다.<br/><br/>
첫 번째 문제와 마찬가지로 리턴할 값인 answer을 동적 할당해 주어야 한다.<br/>
일단 동적 할당을 해줘야 한다.<br/><br/>
한글은 2Byte니까 2Byte*n 칸이 필요하니 char* answer = (char*)malloc(sizeof(char) * 2 * n);로 해주면 된다.<br/>
...라고 생각하기 쉽지만 그렇지 않다.<br/><br/>
문자열의 마지막에는 '\0', 즉 NULL 값이 들어가기 때문이다. '수'나 '박'도 마찬가지다. 사실 '수'가 아닌 '수\0'이라는 뜻이다.<br/>
따라서 한글 2Byte + NULL 문자 1Byte = 3Byte를 필요로 한다.<br/><br/>
여기서 잠시 strcat 함수를 살펴봐야 한다.<br/><br/>
strcat(str1, str2); //str1 문자열 뒤에 str2 문자열을 복사해서 붙여 넣음<br/><br/>
앞에서 설명하였듯이, 모든 문자열의 마지막에는 NULL 문자가 붙어 해당 문자열의 끝을 알려준다.<br/>
str1 문자열과 str2문자열 모두 마찬가지로 마지막에는 NULL 문자가 들어간다.<br/>
그런데 strcat 함수를 사용하면 str1의 \0이 저장된 위치부터 덧붙여진다.<br/><br/>
이 소스코드의 경우<br/><br/>
n=2 //수\0 + 박\0<br/>
n=3 //수박\0 + 수\0<br/>
n=4 //수박수\0 + 박\0<br/>
n=5 //수박수박\0 + 수\0<br/>
...<br/><br/>
이런 식으로 진행된다는 소리다.<br/><br/>
따라서, char* answer = (char*)malloc(sizeof(char) * (2 * n + 1));을 해주면 된다.<br/>
다만, 어째서인지 프로그래머스에서는 3Byte로 취급되는지<br/>
char* answer = (char*)malloc(sizeof(char) * 3 * n);을 해주어야 실행 시 적절하게 모든 케이스를 통과할 수 있다.<br/><br/> 
아마 strcat을 고려하지 않고 '수\0'를 3Byte로 취급하는 탓인 듯하다.<br/><br/>
이제 동적 할당은 완료했다. 그런데 이렇게 동적 할당만 해주고 실행하면 이상한 한자가 출력된다.<br/><br/>
문자열을 malloc을 통해서 동적 할당을 하면 동적 할당한 칸에는 쓰레기 값들이 들어가게 된다.<br/>
이러한 쓰레기 값을 제거해 주지 않으면 쓰레기 값들, 즉 이상한 한자 뒤에 수박수박...이 출력된다.<br/><br/>
이 쓰레기 값을 제거해 주는 것이 memset 함수이다.<br/><br/>
memset 함수의 원형은 memset (포인터, 값, 크기);이다.<br/>
포인터 변수에서 크기만큼의 바이트를 값으로 바꾸는 함수이다.<br/>
즉,  memset(answer, NULL, sizeof(answer));는 answer 변수에서 sizeof(answer) 바이트만큼을<br/>
NULL 값으로 바꾸어 쓰레기 값을 청소해 주는 코드이다.<br/><br/>
이렇게 할당된 값을 청소까지 해주고 나면 이제 값을 넣을 차례다.<br/><br/>
int i = 1부터 i가 n이 될 때까지 while 반복문으로 반복을 해준다.<br/>
그리고 i를 2로 나눈 나머지가 0이 아닐 때, 즉 i가 홀수일 때는 '수'를, 짝수일 때는 '박'을<br/>
answer에 채워 출력하면 된다.<br/><br/>
이제 모두 완료한 것 같지만 마지막으로 해줄 일이 남았다.<br/><br/>
전통적인 C언어에서는 스택 영역에 선언된 변수(ex - 지역변수, 매개변수 등)는 따로 메모리 해제를 해주지 않아도<br/>
해당 블록이 종료가 됨 과 동시에 알아서 메모리 해제가 되지만, 반면 힙 영역에 동적으로 할당된 변수는<br/>
반드시 free() 함수를 사용하여 메모리 해제를 해주어야 한다. 즉, malloc 함수와 free 함수는 한 쌍이라고 할 수 있다.<br/><br/>
메모리 해제를 하지 않으면 메모리 내의 프로세스 무게가 더해져서 램에 남아있는 공간이 적어지게 되고,<br/>
언젠가는 프로그램이 다운되는 등 오류가 발생하게 된다. 이러한 오류를 메모리 누수(Memory Leak)라고 하는데,<br/>
이것을 방지하는 것은 개발자의 핵심 역량이라고 할 수 있으므로 많은 신경을 써야 한다.<br/><br/>


**4. 약수의 합**<br/>

![약수의_합](https://user-images.githubusercontent.com/76294398/104331923-fd388e80-5532-11eb-9dba-00a91aaabdb6.jpg)<br/><br/>
프로그래머스 코딩테스트 Lv.1 네 번째 문제이다.<br/>
약 만천 명 정도가 풀었다. 푼 사람 수가 많은 만큼, 수학적인 공식만 알면 쉬운 문제이다.<br/><br/>
정수 n을 입력받은 후, 정수 n의 약수를 모두 더하여 답을 도출하는 소스코드를 작성해야한다.<br/><br/>
제한조건을 보니, n은 0도 포함한다는 것을 알 수 있다. 이 조건이 어떻게 작용할지는 아직 몰라도 체크해서 나쁠 것은 없다.<br/>
어떤 정수를 그 정수의 약수로 나눌 경우 나머지가 0이 된다.<br/>
따라서, i 를 1부터 증가시키면서 n 까지 반복하여 나머지가 0이 되는 i 의 값을 answer에 더하면 된다.<br/><br/> 
오늘은 정말 특별한 것이 없는, 굉장히 쉬운 문제였다. 하지만 이것만 보고 넘기면 절대 실력이 늘지 않는다. 소스코드를 보지 않고 직접 풀어보는 과정이 필수적일 것이다.<br/><br/>


**5. 자릿수 더하기**<br/>

![자릿수](https://user-images.githubusercontent.com/76294398/104332332-68826080-5533-11eb-9cbc-a4786c4ac2fc.jpg)<br/><br/>
프로그래머스 코딩테스트 Lv.1 다섯번째 문제이다.<br/><br/>
3월 15일 기준 약 7천명 정도가 풀었다.<br/>
상당히 쉬운 편에 속하는 문제지만, 기본적인 구상을 하지 못하면 또 상당히 어려운 문제가 될 수도 있는 문제라고 생각한다.<br/>
코드가 사람마다 천차만별로 다를 수 있는, 재밌는 문제라고 느껴졌다.<br/><br/>
제한사항을 보니, 커봐야 9자리겠구나 싶은 정도의 생각만 든다. 별 거 없는 것 같지만 체크는 해두도록 하자.<br/><br/>
int 형 값을 입력받아 int 형 값을 리턴하는 함수를 만들면 되겠다.<br/><br/>
입력 받는 값의 각 자릿수를 모두 더해 출력하는 것이 목표이다.<br/>
일단 나는 수를 10의 제곱수로 나누어서 나온 몫을 이용할 생각을 했다. 만약 1234라면 103으로 나눈 몫인 1을 answer에 더하고<br/>
1234에서 1 X 103을 한 수를 int n에 다시 저장한 후 234를 같은 방식으로 반복하는 코드를 생각했다.<br/><br/>
여기서 10의 제곱수를 만들기 위해 pow 함수를 추가로 만들어주었다. x의 y 제곱을 구하는 함수로, y가 0일 경우 x의 값에 상관없이<br/>
1을 리턴하도록 했다. 수학적인 공식은 재귀함수를 이용하면 간단히 작성이 가능하다.<br/><br/>
바로 위에서도 설명했지만, 다시 설명하도록 하겠다.<br/><br/>
먼저 ten 이라는 변수에 10을 저장하여 10의 제곱수를 만들 수 있도록 하였다. 또, 내 코드에서는 n을 매번 바꿔줘야한다.<br/>
따라서, n을 바꾸기 전에 자릿수의 합을 잠시 저장할 변수가 필요하므로 sum이라는 변수를 설정해주었다.<br/><br/>
그다음 for문을 사용해서 자릿수를 나눠줬는데, 이 과정에서는 제한조건을 살짝 이용했다. 이렇게 앞 쪽 자릿수부터<br/>
차례로 answer에 추가시킴으로써 답을 도출해냈다.<br/><br/>
이후 방식을 바꿔 좀 더 깔끔한 코드를 고안했다.<br/><br/>
단순히 자릿수를 계산하는 방향만 바꿨을 뿐인데 정말 깔끔해진 것일 볼 수 있다.<br/>
n을 10으로 나눈 나머지를 구해 더하고 n은 다시 10으로 나누어 몫으로 바꿔줌으로써 낮은 자릿수부터 더했다.<br/><br/>
이 외에도 정말 다양한 코드가 나올 수 있는 재밌는 문제이므로 꼭 한번 시도해보기를 추천한다.<br/><br/>


**6. 자연수 뒤집어 배열로 만들기**<br/>

![자배](https://user-images.githubusercontent.com/76294398/104445326-53add780-55dc-11eb-8051-d2e53d205c34.jpg)<br/><br/>
프로그래머스 코딩 테스트 Lv.1 여섯 번째 문제이다.<br/><br/>
3월 16일 기준 약 6100명이 풀었다.<br/>
처음 풀 때 다소 당황스러웠던 문제 중 하나이다. 그래도 그렇게 어렵지는 않으니 차근차근 풀어보도록 하자.<br/><br/>
제한조건을 보니 n은 11자리 이하임을 알 수 있다.<br/>
return 값인 answer을 동적 할당 시켜줘야 한다. 일단 answer의 값은 int형이므로 (int*)malloc(sizeof(int))를 해줘야 한다.<br/>
여기서, 제한조건에 의해 n은 11자리 이하이므로 넉넉잡아 16 정도 곱해주면 된다.<br/>
따라서 동적 할당 부분은  int* answer = (int*)malloc(sizeof(int) * 16);<br/><br/>
이제 배열을 동적 할당 시켜줬으니 배열의 각 칸에 값을 저장해 줄 차례이다.<br/>
이전 코드에서 자릿수를 나눴던 방식을 응용하면 쉽게 나눌 수 있다.<br/><br/>
가닥만 잡으면 그다지 어렵지 않다. 하지만 아무것도 없는 상태에서 만들 때는 다소 막막할 수 있으니 꼭 한번 스스로 해보기를 바란다.<br/><br/>
